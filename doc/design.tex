\documentclass[a4paper]{article}
\usepackage{amsmath,amssymb,bm,hyperref}
\title{DOHP: Implementation of the Dual Order $hp$ element method}
\author{Jed Brown}

\newcommand{\struct}[1]{\texttt{#1}}
\newcommand{\trl}[1]{\texttt{#1}}

\begin{document}
\maketitle

\section{MFS: Mesh Function Space}
Each element has exactly one quadrature rule.  It is chosen to be sufficient to
integrate the highest order approximation used.  The element coordinate mapping
must be evaluated at quadrature points.  For affine mappings, the Jacobian is
constant on each element so this is trivial.  For parametric mappings, element
Jacobian storage is needed at each quadrature point.

An \struct{ElemCtx} is stored once for every element in the mesh. It contains a
quadrature rule, a coordinate mapping, and an offset into the stored Jacobian
context.

One problem may have several fields with different order approximation.  Each
field can have any number of degrees of freedom.  All fields use the same
quadrature rule and the same Jacobian storage.\footnote{It would be possible to
  use separate Jacobian storage for each block of the Jacobian.  This would
  minimize memory access when evaluating the action of any particular block, but
  I conjecture that it would not a big win and would add significant coding
  complexity to several components.}  That is, each \trl{EFS} (Element Function
Space) is relative to an \struct{ElemCtx}.  An \trl{MFS} extends an \trl{EFS} to
a subdomain of a \trl{Mesh} and supports one field which may have any number of
degrees of freedom.  A problem normally has multiple \trl{MFS}, but frequently
any block of the Jacobian containing more than one \trl{MFS} is
indefinite.\footnote{For this reason, we are not overly concerned with
  generating explicit (preconditioning) matrices for blocks corresponding to
  multiple \trl{MFS}.  However, an optimization for very low order elements is
  to actually generate the matrix entries so we still want it to be possible.}


\section{$*$ spaces}
A processor local space contains a vertex space $V$, an edge space $E$, a face
space $F$, and a cell space $C$.  The product $A = V \times E \times F \times C$
defines the total local degrees of freedom.  These spaces consist of only
``internal'' degrees of freedom.  Fast computation kernels operate on entire
cells $C^*$, not just internal degrees of freedom.  We would like to perform all
problem specific operations on $C^*$ (and $F^*$ for boundary conditions) which
requires a fast $*$ operation.  We would like it to be as memory friendly as
possible while keeping the operation count low.  One option is
\begin{eqnarray*}  \label{eq:star}
  V^* &=& V \\
  (V^*,E) &\to& E^* \\
  (E^*,F) &\to& F^* \\
  (F^*,C) &\to& C^*
\end{eqnarray*}
The last step uses the most memory and can easily be hoisted into the
computation loop.  Hoisting other computations will duplicate computation and
reduce memory locality.
\end{document}
