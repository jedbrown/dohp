#include "modalimpl.h"
#include <dohp.h>
#include <dohpmesh.h>           /* iMesh_TypeFromTopology */

const char *const dJacobiModalFamilies[] = {
  "p-conforming",
  "p-discontinuous",
  "q-conforming",
  "q-discontinuous",
  "dJacobiModalFamilies",
  "dJACOBI_MODAL_",
  0
};

static dErr ModalPCount(dEntType type,dInt order,dInt *count) {
  dFunctionBegin;
  switch (type) {
    case dTYPE_EDGE:
      *count = order+1; break;
    case dTYPE_FACE:
      switch (order) {
        case 0: *count = 1; break;
        case 1: *count = 3; break;
        case 2: *count = 6; break;
        case 3: *count = 10; break;
        default: dERROR(PETSC_ERR_SUP,"Order %D for type %s",order,dMeshEntTypeName(type));
      }
      break;
    case dTYPE_REGION:
      switch (order) {
        case 0: *count = 1; break;
        case 1: *count = 4; break;
        case 2: *count = 10; break;
        case 3: *count = 18; break;
        default: dERROR(PETSC_ERR_SUP,"Order %D for type %s",order,dMeshEntTypeName(type));
      }
      break;
    default: dERROR(PETSC_ERR_ARG_OUTOFRANGE,"Unknown type %s",dMeshEntTypeName(type));
  }
  dFunctionReturn(0);
}

/** Set up a modal basis corresponding to P_k elements **/
static dErr dEFSModalSetUp(dEFS_Modal *modal,dEntTopology topo,dRule rule,dInt order)
{
  dInt P,Q;
  dReal *rcoord;
  dErr err;

  dFunctionBegin;
  err = dRuleGetSize(rule,NULL,&Q);dCHK(err);
  err = dMallocA(3*Q,&rcoord);dCHK(err);
  err = dRuleGetNodeWeight(rule,rcoord,NULL);dCHK(err);
  modal->topo = topo;
  modal->rule = rule;
  err = ModalPCount(dMeshEntTypeFromTopology(topo),order,&P);dCHK(err);
  modal->P   = P;
  modal->Q   = Q;
  err = dMallocA2(P*Q,&modal->interp,3*P*Q,&modal->deriv);dCHK(err);
  for (dInt i=0; i<Q; i++) {
    dReal *interp = &modal->interp[i*P],(*deriv)[3] = (dReal(*)[3])&modal->deriv[i*P*3];
    dReal x,y,z;
    x = rcoord[i*3+0];
    y = rcoord[i*3+1];
    z = rcoord[i*3+2];
    /* The following code was generated by sympy using Gram-Schmidt orthogonalization of the basis functions on the
    * reference element.  This produces a diagonal mass matrix. */
    switch (topo) {
      case dTOPO_LINE:
        switch (order) {
          case 3:
            interp[3] = -3*x*sqrt(14)/4 + 5*sqrt(14)*pow(x,3)/4;
            deriv[3][0] = -3*sqrt(14)/4 + 15*sqrt(14)*pow(x,2)/4;
            deriv[3][1] = 0;
            deriv[3][2] = 0;
          case 2:
            interp[2] = sqrt(10.)/4. * (-1. + 3.*x*x);
            deriv[2][0] = sqrt(10.)/4. * 6.*x;
            deriv[2][1] = 0;
            deriv[2][2] = 0;
          case 1:
            interp[1] = x*sqrt(6)/2;
            deriv[1][0] = sqrt(6)/2;
            deriv[1][1] = 0;
            deriv[1][2] = 0;
          case 0:
            interp[0] = sqrt(2)/2;
            deriv[0][0] = 0;
            deriv[0][1] = 0;
            deriv[0][2] = 0;
        }
        break;
      case dTOPO_QUAD:
        switch (order) {
          case 3:
            interp[9] = -x*sqrt(15)/4 + 3*x*sqrt(15)*pow(y,2)/4;
            deriv[9][0] = -sqrt(15)/4 + 3*sqrt(15)*pow(y,2)/4;
            deriv[9][1] = 3*x*y*sqrt(15)/2;
            deriv[9][2] = 0;
            interp[8] = -y*sqrt(15)/4 + 3*y*sqrt(15)*pow(x,2)/4;
            deriv[8][0] = 3*x*y*sqrt(15)/2;
            deriv[8][1] = -sqrt(15)/4 + 3*sqrt(15)*pow(x,2)/4;
            deriv[8][2] = 0;
            interp[7] = -3*y*sqrt(7)/4 + 5*sqrt(7)*pow(y,3)/4;
            deriv[7][0] = 0;
            deriv[7][1] = -3*sqrt(7)/4 + 15*sqrt(7)*pow(y,2)/4;
            deriv[7][2] = 0;
            interp[6] = -3*x*sqrt(7)/4 + 5*sqrt(7)*pow(x,3)/4;
            deriv[6][0] = -3*sqrt(7)/4 + 15*sqrt(7)*pow(x,2)/4;
            deriv[6][1] = 0;
            deriv[6][2] = 0;
          case 2:
            interp[5] = 3*x*y/2;
            deriv[5][0] = 3*y/2;
            deriv[5][1] = 3*x/2;
            deriv[5][2] = 0;
            interp[4] = -sqrt(5)/4 + 3*sqrt(5)*pow(y,2)/4;
            deriv[4][0] = 0;
            deriv[4][1] = 3*y*sqrt(5)/2;
            deriv[4][2] = 0;
            interp[3] = -sqrt(5)/4 + 3*sqrt(5)*pow(x,2)/4;
            deriv[3][0] = 3*x*sqrt(5)/2;
            deriv[3][1] = 0;
            deriv[3][2] = 0;
          case 1:
            interp[2] = y*sqrt(3)/2;
            deriv[2][0] = 0;
            deriv[2][1] = sqrt(3)/2;
            deriv[2][2] = 0;
            interp[1] = x*sqrt(3)/2;
            deriv[1][0] = sqrt(3)/2;
            deriv[1][1] = 0;
            deriv[1][2] = 0;
          case 0:
            interp[0] = 1.0/2.0;
            deriv[0][0] = 0;
            deriv[0][1] = 0;
            deriv[0][2] = 0;
        }
        break;
      case dTOPO_HEX:
        switch (order) {
          case 3:
            interp[17] = 3*x*y*z*sqrt(6)/4;
            deriv[17][0] = 3*y*z*sqrt(6)/4;
            deriv[17][1] = 3*x*z*sqrt(6)/4;
            deriv[17][2] = 3*x*y*sqrt(6)/4;
            interp[16] = -x*sqrt(30)/8 + 3*x*sqrt(30)*pow(z,2)/8;
            deriv[16][0] = -sqrt(30)/8 + 3*sqrt(30)*pow(z,2)/8;
            deriv[16][1] = 0;
            deriv[16][2] = 3*x*z*sqrt(30)/4;
            interp[15] = -z*sqrt(30)/8 + 3*z*sqrt(30)*pow(x,2)/8;
            deriv[15][0] = 3*x*z*sqrt(30)/4;
            deriv[15][1] = 0;
            deriv[15][2] = -sqrt(30)/8 + 3*sqrt(30)*pow(x,2)/8;
            interp[14] = -x*sqrt(30)/8 + 3*x*sqrt(30)*pow(y,2)/8;
            deriv[14][0] = -sqrt(30)/8 + 3*sqrt(30)*pow(y,2)/8;
            deriv[14][1] = 3*x*y*sqrt(30)/4;
            deriv[14][2] = 0;
            interp[13] = -y*sqrt(30)/8 + 3*y*sqrt(30)*pow(x,2)/8;
            deriv[13][0] = 3*x*y*sqrt(30)/4;
            deriv[13][1] = -sqrt(30)/8 + 3*sqrt(30)*pow(x,2)/8;
            deriv[13][2] = 0;
            interp[12] = -3*z*sqrt(14)/8 + 5*sqrt(14)*pow(z,3)/8;
            deriv[12][0] = 0;
            deriv[12][1] = 0;
            deriv[12][2] = -3*sqrt(14)/8 + 15*sqrt(14)*pow(z,2)/8;
            interp[11] = -3*y*sqrt(14)/8 + 5*sqrt(14)*pow(y,3)/8;
            deriv[11][0] = 0;
            deriv[11][1] = -3*sqrt(14)/8 + 15*sqrt(14)*pow(y,2)/8;
            deriv[11][2] = 0;
            interp[10] = -3*x*sqrt(14)/8 + 5*sqrt(14)*pow(x,3)/8;
            deriv[10][0] = -3*sqrt(14)/8 + 15*sqrt(14)*pow(x,2)/8;
            deriv[10][1] = 0;
            deriv[10][2] = 0;
          case 2:
            interp[9] = 3*x*z*sqrt(2)/4;
            deriv[9][0] = 3*z*sqrt(2)/4;
            deriv[9][1] = 0;
            deriv[9][2] = 3*x*sqrt(2)/4;
            interp[8] = 3*y*z*sqrt(2)/4;
            deriv[8][0] = 0;
            deriv[8][1] = 3*z*sqrt(2)/4;
            deriv[8][2] = 3*y*sqrt(2)/4;
            interp[7] = 3*x*y*sqrt(2)/4;
            deriv[7][0] = 3*y*sqrt(2)/4;
            deriv[7][1] = 3*x*sqrt(2)/4;
            deriv[7][2] = 0;
            interp[6] = -sqrt(10)/8 + 3*sqrt(10)*pow(z,2)/8;
            deriv[6][0] = 0;
            deriv[6][1] = 0;
            deriv[6][2] = 3*z*sqrt(10)/4;
            interp[5] = -sqrt(10)/8 + 3*sqrt(10)*pow(y,2)/8;
            deriv[5][0] = 0;
            deriv[5][1] = 3*y*sqrt(10)/4;
            deriv[5][2] = 0;
            interp[4] = -sqrt(10)/8 + 3*sqrt(10)*pow(x,2)/8;
            deriv[4][0] = 3*x*sqrt(10)/4;
            deriv[4][1] = 0;
            deriv[4][2] = 0;
          case 1:
            interp[3] = z*sqrt(6)/4;
            deriv[3][0] = 0;
            deriv[3][1] = 0;
            deriv[3][2] = sqrt(6)/4;
            interp[2] = y*sqrt(6)/4;
            deriv[2][0] = 0;
            deriv[2][1] = sqrt(6)/4;
            deriv[2][2] = 0;
            interp[1] = x*sqrt(6)/4;
            deriv[1][0] = sqrt(6)/4;
            deriv[1][1] = 0;
            deriv[1][2] = 0;
          case 0:
            interp[0] = sqrt(2)/4;
            deriv[0][0] = 0;
            deriv[0][1] = 0;
            deriv[0][2] = 0;
        }
        break;
      default: dERROR(PETSC_ERR_SUP,"topology %s",dMeshEntTopologyName(topo));
    }
  }
  err = dFree(rcoord);dCHK(err);
  dFunctionReturn(0);
}

static dErr dJacobiDestroy_Modal(dJacobi jac)
{
  dJacobi_Modal *modal = jac->data;
  dErr err;

  dFunctionBegin;
  for (khiter_t k=kh_begin(modal->efs); k!=kh_end(modal->efs); k++) {
    dEFS_Modal *efs;
    if (!kh_exist(modal->efs,k)) continue;
    efs = kh_val(modal->efs,k);
    err = dFree2(efs->interp,efs->deriv);dCHK(err);
    err = dFree(efs);dCHK(err);
  }
  kh_destroy_efs(modal->efs);
  for (dQuadratureMethod m=0; m<dQUADRATURE_METHOD_INVALID; m++) {
    if (jac->quad[m]) {err = dQuadratureDestroy(jac->quad[m]);dCHK(err);}
  }
  err = dFree3(modal->efsOpsLine,modal->efsOpsQuad,modal->efsOpsHex);dCHK(err);
  err = dFree(modal);dCHK(err);
  dFunctionReturn(0);
}

static dErr dJacobiView_Modal(dJacobi jac,PetscViewer viewer)
{
  dJacobi_Modal *modal = jac->data;
  dTruth ascii;
  dErr err;

  dFunctionBegin;
  err = PetscTypeCompare((PetscObject)viewer,PETSCVIEWERASCII,&ascii);dCHK(err);
  if (!ascii) dERROR(PETSC_ERR_SUP,"only ASCII");
  err = PetscViewerASCIIPrintf(viewer,"Modal Jacobi\n");dCHK(err);
  err = PetscViewerASCIIPrintf(viewer,"Cache of EFS\n");dCHK(err);
  err = PetscViewerASCIIPushTab(viewer);dCHK(err);
  for (khiter_t k=kh_begin(modal->efs); k!=kh_end(modal->efs); k++) {
    if (!kh_exist(modal->efs,k)) continue;
    err = dEFSView((dEFS)kh_val(modal->efs,k),viewer);dCHK(err);
  }
  err = PetscViewerASCIIPopTab(viewer);dCHK(err);
  dFunctionReturn(0);
}

static dErr dJacobiModalSetFamily_Modal(dJacobi jac,dJacobiModalFamily family)
{
  dJacobi_Modal *modal = jac->data;

  dFunctionBegin;
  if (family != dJACOBI_MODAL_P_DISCONTINUOUS)
    dERROR(PETSC_ERR_SUP,"only P-discontinuous");
  modal->family = family;
  dFunctionReturn(0);
}

static dErr dJacobiSetFromOptions_Modal(dJacobi jac)
{
  dJacobiModalFamily family = dJACOBI_MODAL_P_DISCONTINUOUS;
  dErr err;

  dFunctionBegin;
  err = PetscOptionsHead("Tensor options");dCHK(err);
  {
    err = PetscOptionsEnum("-djac_modal_family","Family of modal element","dJacobiModalSetFamily",dJacobiModalFamilies,family,(PetscEnum*)&family,NULL);dCHK(err);
    err = dJacobiModalSetFamily(jac,family);dCHK(err);
  }
  err = PetscOptionsTail();dCHK(err);
  dFunctionReturn(0);
}

static dErr dJacobiGetNodeCount_Modal(dJacobi dUNUSED jac,dInt count,const dEntTopology top[],const dPolynomialOrder deg[],dInt inode[],dInt xnode[])
{
  dErr err;

  dFunctionBegin;
  for (dInt i=0; i<count; i++) {
    dInt n,type = dMeshEntTypeFromTopology(top[i]);
    err = ModalPCount(type,dPolynomialOrderMax(deg[i]),&n);dCHK(err);
    if (inode) inode[i] = n;
    if (xnode) xnode[i] = n;
  }
  dFunctionReturn(0);
}

static dErr dJacobiGetConstraintCount_Modal(dUNUSED dJacobi jac,dInt nx,const dInt xi[],const dUNUSED dInt xs[],const dInt dUNUSED is[],
                                             const dPolynomialOrder dUNUSED deg[],dMeshAdjacency ma,dInt nnz[],dInt pnnz[])
{

  dFunctionBegin;
  for (dInt i=0; i<nx; i++) {
    const dInt ei = xi[i];
    switch (ma->topo[ei]) {
      default:
        for (dInt j=xs[i]; j<xs[i+1]; j++) {
          nnz[j] = pnnz[j] = 1;
        }
    }
  }
  dFunctionReturn(0);
}

static dErr dJacobiAddConstraints_Modal(dJacobi dUNUSED jac,dInt nx,const dInt xi[],const dInt xs[],const dInt is[],const dPolynomialOrder dUNUSED deg[],dMeshAdjacency dUNUSED ma,Mat matE,Mat matEp)
{
  dErr err;

  dFunctionBegin;
  for (dInt elem=0; elem<nx; elem++) {
    const dInt ei = xi[elem]; /* Element index, \a is, \a deg and everything in \a ma is addressed by \a ei. */
    if (xs[ei+1]-xs[ei] != is[ei+1]-is[ei])
      dERROR(PETSC_ERR_PLIB,"Different number of interior and expanded nodes with discontinuous element");
    for (dInt i=xs[ei],j=is[ei]; i<xs[i+1]; i++,j++) {
      err = MatSetValue(matE,i,j,1.0,INSERT_VALUES);dCHK(err);
      if (matEp != matE) {
        err = MatSetValue(matEp,i,j,1.0,INSERT_VALUES);dCHK(err);
      }
    }
  }
  dFunctionReturn(0);
}

static dErr dJacobiGetEFS_Modal(dJacobi jac,dInt n,const dEntTopology topo[],const dPolynomialOrder degree[],const dRule rules[],dEFS efs[])
{
  dJacobi_Modal *modal = jac->data;
  dErr          err;

  dFunctionBegin;
  for (dInt i=0; i<n; i++) {
    int new;
    khu_efskey_t key = {topo[i],degree[i],rules[i]};
    khiter_t kiter = kh_put_efs(modal->efs,key,&new);
    if (new) {
      dEFS_Modal *newefs;
      err = dNewLog(jac,dEFS_Modal,&newefs);dCHK(err);
      err = dEFSModalSetUp(newefs,topo[i],rules[i],dPolynomialOrderMax(degree[i]));dCHK(err);
      switch (topo[i]) {
        case dTOPO_LINE:
          newefs->ops = *modal->efsOpsLine;
          break;
        case dTOPO_QUAD:
          newefs->ops = *modal->efsOpsQuad;
          break;
        case dTOPO_HEX:
          newefs->ops = *modal->efsOpsHex;
          break;
        default:
          dERROR(1,"no basis available for given topology");
      }
      kh_val(modal->efs,kiter) = newefs;
    }
    efs[i] = (dEFS)kh_val(modal->efs,kiter);
  }
  dFunctionReturn(0);
}

dErr dJacobiCreate_Modal(dJacobi jac)
{
  static const struct _dJacobiOps myops = {
    .SetFromOptions     = dJacobiSetFromOptions_Modal,
    .Destroy            = dJacobiDestroy_Modal,
    .View               = dJacobiView_Modal,
    .PropagateDown      = 0,
    .GetEFS             = dJacobiGetEFS_Modal,
    .GetNodeCount       = dJacobiGetNodeCount_Modal,
    .GetConstraintCount = dJacobiGetConstraintCount_Modal,
    .AddConstraints     = dJacobiAddConstraints_Modal,
  };
  dJacobi_Modal *modal;
  dErr err;

  dFunctionBegin;
  err = dMemcpy(jac->ops,&myops,sizeof myops);dCHK(err);
  err = dNewLog(jac,dJacobi_Modal,&modal);dCHK(err);
  jac->data = modal;

  err = PetscObjectComposeFunctionDynamic((PetscObject)jac,"dJacobiModalSetFamily_C","dJacobiModalSetFamily_Modal",dJacobiModalSetFamily_Modal);dCHK(err);

  modal->family = dJACOBI_MODAL_P_DISCONTINUOUS;

  modal->efs = kh_init_efs();

  err = dJacobiEFSOpsSetUp_Modal(jac);dCHK(err);
  dFunctionReturn(0);
}

dErr dJacobiModalSetFamily(dJacobi jac,dJacobiModalFamily fam)
{
  dErr err,(*f)(dJacobi,dJacobiModalFamily);

  dFunctionBegin;
  err = PetscObjectQueryFunction((PetscObject)jac,"dJacobiModalSetFamily_C",(void (**)(void))&f);dCHK(err);
  if (f) {
    err = (*f)(jac,fam);dCHK(err);
  }
  PetscFunctionReturn(0);
}
